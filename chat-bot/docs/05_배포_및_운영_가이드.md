# AI 챗봇 배포 및 운영 가이드

## 1. 배포 옵션 비교

| 배포 방식 | 장점 | 단점 | 적합한 경우 | 비용 |
|----------|------|------|------------|------|
| **Streamlit Community Cloud** | 무료, 간편한 배포, GitHub 연동 | 리소스 제한, 커스터마이징 제한 | 프로토타입, 개인 프로젝트 | 무료 |
| **Heroku** | 쉬운 배포, 다양한 애드온 | 무료 플랜 제한, 콜드 스타트 | 소규모 프로덕션 | $7~/월 |
| **AWS EC2** | 완전한 제어, 확장성 | 복잡한 설정, 관리 필요 | 엔터프라이즈 | $10~/월 |
| **Google Cloud Run** | 서버리스, 자동 확장 | 콜드 스타트, 제한된 런타임 | 가변적 트래픽 | 사용량 기반 |
| **Azure App Service** | 엔터프라이즈 지원, CI/CD | 비용이 높음 | 엔터프라이즈 | $13~/월 |

## 2. Streamlit Community Cloud 배포

### 2.1 준비사항

```bash
# 프로젝트 구조 확인
chat-bot/
├── streamlit_app.py       # 필수: 메인 앱 파일
├── requirements.txt        # 필수: 패키지 의존성
├── .streamlit/
│   └── config.toml        # 선택: Streamlit 설정
└── README.md              # 권장: 프로젝트 설명
```

### 2.2 배포 단계

1. **GitHub 저장소 생성**
```bash
git init
git add .
git commit -m "Initial commit"
git remote add origin https://github.com/username/chat-bot.git
git push -u origin main
```

2. **Streamlit Cloud 설정**
- [share.streamlit.io](https://share.streamlit.io) 접속
- GitHub 계정 연결
- 저장소 선택
- 브랜치: main
- 메인 파일: streamlit_app.py

3. **환경 변수 설정**
```toml
# Streamlit Cloud Secrets 설정
[secrets]
OPENAI_API_KEY = "sk-..."
ANTHROPIC_API_KEY = "sk-ant-..."
DATABASE_URL = "sqlite:///./chatbot.db"
```

### 2.3 커스텀 도메인 설정

```yaml
# .streamlit/config.toml
[server]
address = "0.0.0.0"
port = 8501

[browser]
serverAddress = "your-custom-domain.com"
```

## 3. Docker 기반 배포

### 3.1 Docker 이미지 빌드

```dockerfile
# Dockerfile
FROM python:3.11-slim

# 작업 디렉토리 설정
WORKDIR /app

# 시스템 패키지 설치
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    software-properties-common \
    git \
    && rm -rf /var/lib/apt/lists/*

# Python 패키지 설치
COPY requirements.txt .
RUN pip3 install --no-cache-dir -r requirements.txt

# 애플리케이션 복사
COPY . .

# 헬스체크
HEALTHCHECK CMD curl --fail http://localhost:8501/_stcore/health

# 포트 노출
EXPOSE 8501

# 실행
ENTRYPOINT ["streamlit", "run", "streamlit_app.py", \
            "--server.port=8501", "--server.address=0.0.0.0"]
```

### 3.2 Docker Compose 설정

```yaml
# docker-compose.yml
version: '3.8'

services:
  chatbot:
    build: .
    container_name: ai-chatbot
    ports:
      - "8501:8501"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - DATABASE_URL=postgresql://user:pass@db:5432/chatbot
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    depends_on:
      - db
      - redis
    restart: unless-stopped
    networks:
      - chatbot-network

  db:
    image: postgres:15-alpine
    container_name: chatbot-db
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=chatbot
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - chatbot-network

  redis:
    image: redis:7-alpine
    container_name: chatbot-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - chatbot-network

  nginx:
    image: nginx:alpine
    container_name: chatbot-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - chatbot
    networks:
      - chatbot-network

volumes:
  postgres_data:
  redis_data:

networks:
  chatbot-network:
    driver: bridge
```

### 3.3 Nginx 리버스 프록시 설정

```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream streamlit {
        server chatbot:8501;
    }

    server {
        listen 80;
        server_name your-domain.com;
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name your-domain.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        location / {
            proxy_pass http://streamlit;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_read_timeout 86400;
        }

        location /_stcore/stream {
            proxy_pass http://streamlit/_stcore/stream;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_read_timeout 86400;
        }
    }
}
```

## 4. Kubernetes 배포

### 4.1 Kubernetes 매니페스트

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: chatbot-deployment
  labels:
    app: chatbot
spec:
  replicas: 3
  selector:
    matchLabels:
      app: chatbot
  template:
    metadata:
      labels:
        app: chatbot
    spec:
      containers:
      - name: chatbot
        image: your-registry/chatbot:latest
        ports:
        - containerPort: 8501
        env:
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: chatbot-secrets
              key: openai-api-key
        - name: DATABASE_URL
          valueFrom:
            configMapKeyRef:
              name: chatbot-config
              key: database-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /_stcore/health
            port: 8501
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /_stcore/health
            port: 8501
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: chatbot-service
spec:
  selector:
    app: chatbot
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8501
  type: LoadBalancer

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: chatbot-config
data:
  database-url: "postgresql://user:pass@postgres:5432/chatbot"

---
apiVersion: v1
kind: Secret
metadata:
  name: chatbot-secrets
type: Opaque
data:
  openai-api-key: <base64-encoded-key>
```

### 4.2 Helm Chart

```yaml
# helm/values.yaml
replicaCount: 3

image:
  repository: your-registry/chatbot
  pullPolicy: IfNotPresent
  tag: "latest"

service:
  type: LoadBalancer
  port: 80

ingress:
  enabled: true
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: chatbot.your-domain.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: chatbot-tls
      hosts:
        - chatbot.your-domain.com

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
```

## 5. CI/CD 파이프라인

### 5.1 GitHub Actions

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov
    
    - name: Run tests
      run: |
        pytest tests/ --cov=src --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and push
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: |
          ${{ secrets.DOCKER_USERNAME }}/chatbot:latest
          ${{ secrets.DOCKER_USERNAME }}/chatbot:${{ github.sha }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
    - name: Deploy to server
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          cd /opt/chatbot
          docker-compose pull
          docker-compose up -d --no-deps --build chatbot
          docker system prune -f
```

### 5.2 GitLab CI/CD

```yaml
# .gitlab-ci.yml
stages:
  - test
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

test:
  stage: test
  image: python:3.11
  script:
    - pip install -r requirements.txt
    - pip install pytest pytest-cov
    - pytest tests/ --cov=src
  coverage: '/TOTAL.*\s+(\d+%)$/'

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  only:
    - main

deploy:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | ssh-add -
  script:
    - ssh -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_HOST "cd /opt/chatbot && docker-compose pull && docker-compose up -d"
  only:
    - main
```

## 6. 모니터링 및 관찰성

### 6.1 Prometheus + Grafana 설정

```yaml
# docker-compose.monitoring.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    ports:
      - "9090:9090"
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3000:3000"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
      - GF_INSTALL_PLUGINS=redis-datasource

  node_exporter:
    image: prom/node-exporter:latest
    container_name: node_exporter
    ports:
      - "9100:9100"

  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    container_name: cadvisor
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro

volumes:
  prometheus_data:
  grafana_data:
```

### 6.2 로깅 스택 (ELK)

```yaml
# docker-compose.logging.yml
version: '3.8'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
    volumes:
      - es_data:/usr/share/elasticsearch/data

  logstash:
    image: docker.elastic.co/logstash/logstash:8.11.0
    container_name: logstash
    volumes:
      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf
    ports:
      - "5000:5000"
    depends_on:
      - elasticsearch

  kibana:
    image: docker.elastic.co/kibana/kibana:8.11.0
    container_name: kibana
    ports:
      - "5601:5601"
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    depends_on:
      - elasticsearch

  filebeat:
    image: docker.elastic.co/beats/filebeat:8.11.0
    container_name: filebeat
    volumes:
      - ./filebeat.yml:/usr/share/filebeat/filebeat.yml
      - ./logs:/logs
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro

volumes:
  es_data:
```

### 6.3 애플리케이션 메트릭

```python
# src/utils/metrics.py
from prometheus_client import Counter, Histogram, Gauge, generate_latest
import streamlit as st
import time

# 메트릭 정의
request_count = Counter('chatbot_requests_total', 'Total requests')
response_time = Histogram('chatbot_response_duration_seconds', 'Response time')
active_sessions = Gauge('chatbot_active_sessions', 'Active sessions')
token_usage = Counter('chatbot_tokens_used', 'Total tokens used', ['model'])

def track_request():
    """요청 추적"""
    request_count.inc()

def track_response_time(duration):
    """응답 시간 추적"""
    response_time.observe(duration)

def track_tokens(model, count):
    """토큰 사용량 추적"""
    token_usage.labels(model=model).inc(count)

# Streamlit에 메트릭 노출
@st.cache_data(ttl=60)
def get_metrics():
    """Prometheus 메트릭 가져오기"""
    return generate_latest().decode('utf-8')
```

## 7. 보안 강화

### 7.1 SSL/TLS 설정

```bash
# Let's Encrypt SSL 인증서 설정
sudo apt-get update
sudo apt-get install certbot python3-certbot-nginx

# 인증서 발급
sudo certbot --nginx -d your-domain.com

# 자동 갱신 설정
sudo crontab -e
# 추가: 0 0 * * * /usr/bin/certbot renew --quiet
```

### 7.2 보안 헤더 설정

```nginx
# nginx 보안 헤더
add_header X-Frame-Options "SAMEORIGIN" always;
add_header X-Content-Type-Options "nosniff" always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
```

### 7.3 Rate Limiting

```python
# src/utils/rate_limiter.py
from functools import wraps
import time
from collections import defaultdict
import streamlit as st

class RateLimiter:
    def __init__(self, max_requests=10, window=60):
        self.max_requests = max_requests
        self.window = window
        self.requests = defaultdict(list)
    
    def is_allowed(self, user_id):
        """요청 허용 여부 확인"""
        now = time.time()
        # 윈도우 밖의 요청 제거
        self.requests[user_id] = [
            req_time for req_time in self.requests[user_id]
            if now - req_time < self.window
        ]
        
        if len(self.requests[user_id]) < self.max_requests:
            self.requests[user_id].append(now)
            return True
        return False

rate_limiter = RateLimiter(max_requests=10, window=60)

def rate_limit(func):
    """Rate limiting 데코레이터"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        user_id = st.session_state.get('session_id', 'anonymous')
        if not rate_limiter.is_allowed(user_id):
            st.error("요청이 너무 많습니다. 잠시 후 다시 시도해주세요.")
            return None
        return func(*args, **kwargs)
    return wrapper
```

## 8. 백업 및 복구

### 8.1 자동 백업 스크립트

```bash
#!/bin/bash
# scripts/backup.sh

# 설정
BACKUP_DIR="/backup/chatbot"
DB_NAME="chatbot"
DATE=$(date +%Y%m%d_%H%M%S)

# 디렉토리 생성
mkdir -p $BACKUP_DIR

# PostgreSQL 백업
pg_dump $DB_NAME | gzip > $BACKUP_DIR/db_backup_$DATE.sql.gz

# 애플리케이션 파일 백업
tar -czf $BACKUP_DIR/app_backup_$DATE.tar.gz /opt/chatbot

# Redis 백업
redis-cli --rdb $BACKUP_DIR/redis_backup_$DATE.rdb

# 오래된 백업 삭제 (30일 이상)
find $BACKUP_DIR -type f -mtime +30 -delete

# S3 업로드 (선택사항)
aws s3 sync $BACKUP_DIR s3://your-backup-bucket/chatbot/
```

### 8.2 복구 절차

```bash
#!/bin/bash
# scripts/restore.sh

# 설정
BACKUP_FILE=$1
RESTORE_DIR="/opt/chatbot"

if [ -z "$BACKUP_FILE" ]; then
    echo "Usage: ./restore.sh <backup_file>"
    exit 1
fi

# 서비스 중지
docker-compose down

# 백업 복구
tar -xzf $BACKUP_FILE -C /

# 데이터베이스 복구
gunzip -c db_backup_*.sql.gz | psql chatbot

# Redis 복구
redis-cli --rdb redis_backup_*.rdb

# 서비스 시작
docker-compose up -d

echo "Restoration completed"
```

## 9. 성능 튜닝

### 9.1 Streamlit 최적화

```python
# .streamlit/config.toml
[server]
maxUploadSize = 200
maxMessageSize = 200
enableCORS = false
enableXsrfProtection = true

[runner]
magicEnabled = true
installTracer = false
fixMatplotlib = true

[client]
caching = true
displayEnabled = true

[theme]
primaryColor = "#FF4B4B"
backgroundColor = "#FFFFFF"
secondaryBackgroundColor = "#F0F2F6"
textColor = "#262730"
```

### 9.2 데이터베이스 최적화

```sql
-- PostgreSQL 튜닝
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
ALTER SYSTEM SET wal_buffers = '16MB';
ALTER SYSTEM SET default_statistics_target = 100;
ALTER SYSTEM SET random_page_cost = 1.1;

-- 인덱스 생성
CREATE INDEX idx_messages_session_timestamp ON messages(session_id, timestamp);
CREATE INDEX idx_sessions_user_activity ON sessions(user_id, last_activity);

-- 통계 업데이트
ANALYZE;
```

## 10. 트러블슈팅

### 10.1 일반적인 문제 해결

| 문제 | 증상 | 해결 방법 |
|------|------|-----------|
| 메모리 누수 | 점진적 메모리 증가 | 세션 정리, 캐시 제한 설정 |
| 느린 응답 | 응답 시간 > 5초 | 캐싱 활성화, 인덱스 추가 |
| 연결 끊김 | WebSocket 오류 | Nginx 타임아웃 증가 |
| 세션 손실 | 새로고침 시 초기화 | Redis 세션 저장소 사용 |
| 높은 CPU 사용 | CPU > 80% | 워커 수 조정, 코드 최적화 |

### 10.2 로그 분석

```bash
# 에러 로그 확인
docker logs chatbot --tail 100 | grep ERROR

# 응답 시간 분석
grep "response_time" /var/log/chatbot/app.log | \
  awk '{sum+=$NF; count++} END {print "Average:", sum/count}'

# 메모리 사용량 모니터링
docker stats chatbot --no-stream

# 네트워크 문제 진단
docker exec chatbot ping -c 4 openai.com
```

### 10.3 디버그 모드

```python
# 디버그 모드 활성화
import streamlit as st
import logging

if st.secrets.get("DEBUG_MODE", False):
    logging.basicConfig(level=logging.DEBUG)
    st.sidebar.write("Debug Mode Active")
    st.sidebar.json(st.session_state)
    
    # 성능 프로파일링
    with st.sidebar.expander("Performance Metrics"):
        st.metric("Response Time", f"{response_time:.2f}s")
        st.metric("Token Usage", token_count)
        st.metric("Cache Hit Rate", f"{cache_hit_rate:.1%}")
```