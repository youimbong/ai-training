# AI 챗봇 데이터 모델 및 저장소 설계

## 1. 데이터 모델 개요

### 1.1 데이터 계층 구조
- **세션 계층**: 사용자 세션 및 상태 관리
- **대화 계층**: 메시지 및 대화 컨텍스트
- **설정 계층**: 사용자 설정 및 시스템 구성
- **분석 계층**: 사용량 통계 및 분석 데이터

### 1.2 저장소 전략
- **In-Memory**: 실시간 세션 데이터 (Streamlit SessionState)
- **Persistent Storage**: 대화 히스토리 및 사용자 데이터 (SQLite/PostgreSQL)
- **Cache Storage**: 응답 캐싱 (Redis/In-Memory)
- **Vector Storage**: RAG 지원 시 임베딩 저장 (ChromaDB/Pinecone)

## 2. 핵심 데이터 모델

### 2.1 세션 데이터 모델

```python
from dataclasses import dataclass, field
from typing import Optional, List, Dict
from datetime import datetime
import uuid

@dataclass
class Session:
    """세션 데이터 모델"""
    session_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    user_id: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    last_activity: datetime = field(default_factory=datetime.now)
    status: str = "active"  # active, expired, terminated
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    
    # 세션 메타데이터
    metadata: Dict = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        """딕셔너리 변환"""
        return {
            "session_id": self.session_id,
            "user_id": self.user_id,
            "created_at": self.created_at.isoformat(),
            "last_activity": self.last_activity.isoformat(),
            "status": self.status,
            "ip_address": self.ip_address,
            "user_agent": self.user_agent,
            "metadata": self.metadata
        }
```

### 2.2 메시지 데이터 모델

```python
@dataclass
class Message:
    """메시지 데이터 모델"""
    message_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    session_id: str = None
    role: str = None  # user, assistant, system, function
    content: str = None
    timestamp: datetime = field(default_factory=datetime.now)
    
    # 토큰 정보
    token_count: Optional[int] = None
    
    # 메타데이터
    model_used: Optional[str] = None
    temperature: Optional[float] = None
    response_time: Optional[float] = None  # 응답 시간 (초)
    
    # 피드백
    rating: Optional[int] = None  # 1-5
    feedback: Optional[str] = None
    
    # 추가 정보
    attachments: List[Dict] = field(default_factory=list)
    metadata: Dict = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        """딕셔너리 변환"""
        return {
            "message_id": self.message_id,
            "session_id": self.session_id,
            "role": self.role,
            "content": self.content,
            "timestamp": self.timestamp.isoformat(),
            "token_count": self.token_count,
            "model_used": self.model_used,
            "temperature": self.temperature,
            "response_time": self.response_time,
            "rating": self.rating,
            "feedback": self.feedback,
            "attachments": self.attachments,
            "metadata": self.metadata
        }
```

### 2.3 대화 데이터 모델

```python
@dataclass
class Conversation:
    """대화 데이터 모델"""
    conversation_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    session_id: str = None
    title: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    # 대화 상태
    status: str = "active"  # active, archived, deleted
    
    # 대화 요약
    summary: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    
    # 메시지 리스트
    messages: List[Message] = field(default_factory=list)
    message_count: int = 0
    total_tokens: int = 0
    
    # 메타데이터
    metadata: Dict = field(default_factory=dict)
    
    def add_message(self, message: Message):
        """메시지 추가"""
        self.messages.append(message)
        self.message_count += 1
        if message.token_count:
            self.total_tokens += message.token_count
        self.updated_at = datetime.now()
    
    def to_dict(self) -> Dict:
        """딕셔너리 변환"""
        return {
            "conversation_id": self.conversation_id,
            "session_id": self.session_id,
            "title": self.title,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "status": self.status,
            "summary": self.summary,
            "tags": self.tags,
            "message_count": self.message_count,
            "total_tokens": self.total_tokens,
            "messages": [msg.to_dict() for msg in self.messages],
            "metadata": self.metadata
        }
```

### 2.4 사용자 설정 모델

```python
@dataclass
class UserSettings:
    """사용자 설정 데이터 모델"""
    user_id: str
    
    # AI 설정
    default_model: str = "gpt-3.5-turbo"
    temperature: float = 0.7
    max_tokens: int = 2000
    system_prompt: Optional[str] = None
    
    # UI 설정
    theme: str = "light"  # light, dark, auto
    language: str = "ko"  # ko, en, ja, zh
    font_size: str = "medium"  # small, medium, large
    
    # 기능 설정
    auto_save: bool = True
    stream_response: bool = True
    show_token_count: bool = False
    enable_markdown: bool = True
    
    # API 키 (암호화 저장)
    api_keys: Dict[str, str] = field(default_factory=dict)
    
    # 개인정보 설정
    save_history: bool = True
    share_analytics: bool = False
    
    # 메타데이터
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict:
        """딕셔너리 변환 (API 키 제외)"""
        data = self.__dict__.copy()
        data.pop('api_keys', None)  # 보안상 API 키 제외
        data['created_at'] = self.created_at.isoformat()
        data['updated_at'] = self.updated_at.isoformat()
        return data
```

## 3. 데이터베이스 스키마

### 3.1 SQLite/PostgreSQL 스키마

```sql
-- 세션 테이블
CREATE TABLE sessions (
    session_id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',
    ip_address VARCHAR(45),
    user_agent TEXT,
    metadata JSON,
    
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_last_activity (last_activity)
);

-- 대화 테이블
CREATE TABLE conversations (
    conversation_id VARCHAR(36) PRIMARY KEY,
    session_id VARCHAR(36) NOT NULL,
    title VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',
    summary TEXT,
    tags JSON,
    message_count INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    metadata JSON,
    
    FOREIGN KEY (session_id) REFERENCES sessions(session_id),
    INDEX idx_session_id (session_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);

-- 메시지 테이블
CREATE TABLE messages (
    message_id VARCHAR(36) PRIMARY KEY,
    conversation_id VARCHAR(36) NOT NULL,
    session_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) NOT NULL,
    content TEXT NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    token_count INTEGER,
    model_used VARCHAR(50),
    temperature FLOAT,
    response_time FLOAT,
    rating INTEGER,
    feedback TEXT,
    attachments JSON,
    metadata JSON,
    
    FOREIGN KEY (conversation_id) REFERENCES conversations(conversation_id),
    FOREIGN KEY (session_id) REFERENCES sessions(session_id),
    INDEX idx_conversation_id (conversation_id),
    INDEX idx_session_id (session_id),
    INDEX idx_timestamp (timestamp)
);

-- 사용자 설정 테이블
CREATE TABLE user_settings (
    user_id VARCHAR(36) PRIMARY KEY,
    default_model VARCHAR(50),
    temperature FLOAT,
    max_tokens INTEGER,
    system_prompt TEXT,
    theme VARCHAR(20),
    language VARCHAR(10),
    font_size VARCHAR(20),
    auto_save BOOLEAN DEFAULT TRUE,
    stream_response BOOLEAN DEFAULT TRUE,
    show_token_count BOOLEAN DEFAULT FALSE,
    enable_markdown BOOLEAN DEFAULT TRUE,
    api_keys_encrypted TEXT,  -- 암호화된 JSON
    save_history BOOLEAN DEFAULT TRUE,
    share_analytics BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 사용량 통계 테이블
CREATE TABLE usage_statistics (
    stat_id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36),
    date DATE NOT NULL,
    model VARCHAR(50),
    request_count INTEGER DEFAULT 0,
    total_tokens INTEGER DEFAULT 0,
    total_cost DECIMAL(10, 4) DEFAULT 0,
    avg_response_time FLOAT,
    error_count INTEGER DEFAULT 0,
    
    FOREIGN KEY (user_id) REFERENCES user_settings(user_id),
    INDEX idx_user_date (user_id, date),
    INDEX idx_date (date)
);

-- 캐시 테이블
CREATE TABLE response_cache (
    cache_key VARCHAR(64) PRIMARY KEY,
    prompt_hash VARCHAR(64) NOT NULL,
    model VARCHAR(50),
    response TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    hit_count INTEGER DEFAULT 0,
    
    INDEX idx_prompt_hash (prompt_hash),
    INDEX idx_expires_at (expires_at)
);
```

## 4. 벡터 데이터베이스 스키마 (RAG 지원)

### 4.1 ChromaDB 컬렉션 구조

```python
import chromadb
from chromadb.config import Settings

class VectorStore:
    """벡터 저장소 관리"""
    
    def __init__(self):
        self.client = chromadb.Client(Settings(
            chroma_db_impl="duckdb+parquet",
            persist_directory="./chroma_db"
        ))
        
        # 대화 임베딩 컬렉션
        self.conversation_collection = self.client.create_collection(
            name="conversations",
            metadata={"hnsw:space": "cosine"}
        )
        
        # 문서 임베딩 컬렉션
        self.document_collection = self.client.create_collection(
            name="documents",
            metadata={"hnsw:space": "cosine"}
        )
    
    def add_conversation_embedding(
        self,
        conversation_id: str,
        embeddings: List[float],
        metadata: Dict
    ):
        """대화 임베딩 추가"""
        self.conversation_collection.add(
            embeddings=[embeddings],
            metadatas=[metadata],
            ids=[conversation_id]
        )
    
    def search_similar_conversations(
        self,
        query_embedding: List[float],
        n_results: int = 5
    ):
        """유사 대화 검색"""
        return self.conversation_collection.query(
            query_embeddings=[query_embedding],
            n_results=n_results
        )
```

## 5. 캐싱 전략

### 5.1 다층 캐싱 구조

```python
from enum import Enum

class CacheLevel(Enum):
    """캐시 레벨"""
    L1_MEMORY = "memory"      # In-memory (가장 빠름)
    L2_REDIS = "redis"        # Redis (중간 속도)
    L3_DATABASE = "database"  # Database (느림)

class CacheStrategy:
    """캐싱 전략"""
    
    def __init__(self):
        self.memory_cache = {}  # L1
        self.redis_client = None  # L2
        self.db_cache = None  # L3
        
        # TTL 설정 (초)
        self.ttl = {
            CacheLevel.L1_MEMORY: 300,    # 5분
            CacheLevel.L2_REDIS: 3600,    # 1시간
            CacheLevel.L3_DATABASE: 86400  # 24시간
        }
    
    async def get(self, key: str) -> Optional[Any]:
        """캐시 조회 (계층적)"""
        # L1 체크
        if key in self.memory_cache:
            return self.memory_cache[key]
        
        # L2 체크
        if self.redis_client:
            value = await self.redis_client.get(key)
            if value:
                self.memory_cache[key] = value  # L1에 승격
                return value
        
        # L3 체크
        if self.db_cache:
            value = await self.db_cache.get(key)
            if value:
                # L2, L1에 승격
                if self.redis_client:
                    await self.redis_client.set(key, value)
                self.memory_cache[key] = value
                return value
        
        return None
```

## 6. 데이터 마이그레이션

### 6.1 마이그레이션 스크립트

```python
class DataMigration:
    """데이터 마이그레이션 관리"""
    
    def __init__(self, db_connection):
        self.db = db_connection
        self.version_table = "schema_versions"
    
    async def create_version_table(self):
        """버전 관리 테이블 생성"""
        await self.db.execute("""
            CREATE TABLE IF NOT EXISTS schema_versions (
                version INTEGER PRIMARY KEY,
                applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                description TEXT
            )
        """)
    
    async def apply_migration(self, version: int, sql: str, description: str):
        """마이그레이션 적용"""
        try:
            # 마이그레이션 실행
            await self.db.execute(sql)
            
            # 버전 기록
            await self.db.execute("""
                INSERT INTO schema_versions (version, description)
                VALUES (?, ?)
            """, (version, description))
            
            print(f"Migration {version} applied: {description}")
        except Exception as e:
            print(f"Migration {version} failed: {e}")
            raise
    
    async def get_current_version(self) -> int:
        """현재 스키마 버전 조회"""
        result = await self.db.fetchone("""
            SELECT MAX(version) FROM schema_versions
        """)
        return result[0] if result[0] else 0
```

## 7. 데이터 백업 및 복구

### 7.1 백업 전략

```python
import json
import gzip
from datetime import datetime

class BackupManager:
    """백업 관리 클래스"""
    
    def __init__(self, db_connection, backup_dir: str = "./backups"):
        self.db = db_connection
        self.backup_dir = backup_dir
        os.makedirs(backup_dir, exist_ok=True)
    
    async def create_backup(self) -> str:
        """전체 백업 생성"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = f"{self.backup_dir}/backup_{timestamp}.json.gz"
        
        data = {
            "timestamp": timestamp,
            "sessions": await self._export_table("sessions"),
            "conversations": await self._export_table("conversations"),
            "messages": await self._export_table("messages"),
            "user_settings": await self._export_table("user_settings")
        }
        
        # 압축 저장
        with gzip.open(backup_file, 'wt', encoding='utf-8') as f:
            json.dump(data, f, indent=2)
        
        return backup_file
    
    async def restore_backup(self, backup_file: str):
        """백업 복구"""
        with gzip.open(backup_file, 'rt', encoding='utf-8') as f:
            data = json.load(f)
        
        # 트랜잭션으로 복구
        async with self.db.transaction():
            await self._import_table("sessions", data["sessions"])
            await self._import_table("conversations", data["conversations"])
            await self._import_table("messages", data["messages"])
            await self._import_table("user_settings", data["user_settings"])
    
    async def _export_table(self, table_name: str) -> List[Dict]:
        """테이블 데이터 추출"""
        rows = await self.db.fetch(f"SELECT * FROM {table_name}")
        return [dict(row) for row in rows]
    
    async def _import_table(self, table_name: str, data: List[Dict]):
        """테이블 데이터 복구"""
        if not data:
            return
        
        # 기존 데이터 삭제
        await self.db.execute(f"DELETE FROM {table_name}")
        
        # 데이터 삽입
        for row in data:
            columns = ", ".join(row.keys())
            placeholders = ", ".join(["?" for _ in row])
            values = list(row.values())
            
            await self.db.execute(
                f"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})",
                values
            )
```

## 8. 데이터 정리 및 유지보수

### 8.1 자동 정리 작업

```python
class DataMaintenance:
    """데이터 유지보수 클래스"""
    
    def __init__(self, db_connection):
        self.db = db_connection
    
    async def cleanup_expired_sessions(self, ttl_hours: int = 24):
        """만료된 세션 정리"""
        cutoff_time = datetime.now() - timedelta(hours=ttl_hours)
        
        deleted = await self.db.execute("""
            UPDATE sessions 
            SET status = 'expired'
            WHERE last_activity < ? AND status = 'active'
        """, (cutoff_time,))
        
        return deleted.rowcount
    
    async def cleanup_old_cache(self):
        """만료된 캐시 정리"""
        deleted = await self.db.execute("""
            DELETE FROM response_cache
            WHERE expires_at < CURRENT_TIMESTAMP
        """)
        
        return deleted.rowcount
    
    async def vacuum_database(self):
        """데이터베이스 최적화"""
        await self.db.execute("VACUUM")
        await self.db.execute("ANALYZE")
    
    async def calculate_usage_statistics(self, user_id: str, date: datetime):
        """사용량 통계 계산"""
        stats = await self.db.fetchone("""
            SELECT 
                COUNT(*) as request_count,
                SUM(token_count) as total_tokens,
                AVG(response_time) as avg_response_time,
                SUM(CASE WHEN rating IS NOT NULL THEN 1 ELSE 0 END) as rated_count
            FROM messages
            WHERE session_id IN (
                SELECT session_id FROM sessions WHERE user_id = ?
            )
            AND DATE(timestamp) = DATE(?)
        """, (user_id, date))
        
        return stats
```

## 9. 데이터 보안

### 9.1 암호화 및 보안

```python
from cryptography.fernet import Fernet
import hashlib

class DataSecurity:
    """데이터 보안 클래스"""
    
    def __init__(self, encryption_key: bytes = None):
        if encryption_key:
            self.cipher = Fernet(encryption_key)
        else:
            self.cipher = Fernet(Fernet.generate_key())
    
    def encrypt_api_key(self, api_key: str) -> str:
        """API 키 암호화"""
        return self.cipher.encrypt(api_key.encode()).decode()
    
    def decrypt_api_key(self, encrypted_key: str) -> str:
        """API 키 복호화"""
        return self.cipher.decrypt(encrypted_key.encode()).decode()
    
    def hash_prompt(self, prompt: str) -> str:
        """프롬프트 해싱 (캐시 키용)"""
        return hashlib.sha256(prompt.encode()).hexdigest()
    
    def anonymize_user_data(self, data: Dict) -> Dict:
        """사용자 데이터 익명화"""
        anonymized = data.copy()
        
        # 민감한 필드 마스킹
        if 'ip_address' in anonymized:
            parts = anonymized['ip_address'].split('.')
            anonymized['ip_address'] = f"{parts[0]}.{parts[1]}.xxx.xxx"
        
        if 'user_id' in anonymized:
            anonymized['user_id'] = hashlib.md5(
                anonymized['user_id'].encode()
            ).hexdigest()[:8]
        
        return anonymized
```

## 10. 데이터 내보내기/가져오기

### 10.1 Export/Import 기능

```python
class DataPortability:
    """데이터 이식성 관리"""
    
    @staticmethod
    async def export_conversation_json(conversation: Conversation) -> str:
        """대화 JSON 내보내기"""
        return json.dumps(conversation.to_dict(), indent=2, ensure_ascii=False)
    
    @staticmethod
    async def export_conversation_markdown(conversation: Conversation) -> str:
        """대화 Markdown 내보내기"""
        md = f"# {conversation.title or 'Conversation'}\n\n"
        md += f"**Date**: {conversation.created_at}\n\n"
        
        for msg in conversation.messages:
            role = msg.role.capitalize()
            md += f"## {role}\n\n{msg.content}\n\n"
            if msg.timestamp:
                md += f"*{msg.timestamp}*\n\n"
        
        return md
    
    @staticmethod
    async def import_conversation_json(json_str: str) -> Conversation:
        """JSON에서 대화 가져오기"""
        data = json.loads(json_str)
        
        conversation = Conversation(
            conversation_id=data.get('conversation_id'),
            session_id=data.get('session_id'),
            title=data.get('title'),
            created_at=datetime.fromisoformat(data.get('created_at')),
            updated_at=datetime.fromisoformat(data.get('updated_at'))
        )
        
        for msg_data in data.get('messages', []):
            message = Message(
                message_id=msg_data.get('message_id'),
                session_id=msg_data.get('session_id'),
                role=msg_data.get('role'),
                content=msg_data.get('content'),
                timestamp=datetime.fromisoformat(msg_data.get('timestamp'))
            )
            conversation.add_message(message)
        
        return conversation
```